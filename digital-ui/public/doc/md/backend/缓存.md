# 缓存

项目提供了两套缓存方案，`ehcache`和`redis`

默认为`ehcache`，不需要额外安装，项目启动即生效，不支持分布式部署，项目关闭即缓存失效；

`redis`方案需要额外安装redis服务端，支持分布式部署，缓存有效性不受项目关闭影响；

## 切换方法：

1. 在对应环境yml配置文件中，将`ehcache`改为`redis`

```properties
spring.cache.type=redis
```

2. 修改`spring.redis.*`，指向安装好的redis服务器

## 使用方法

### 1. 新增缓存类型

需要新增缓存类型时，都必须在`com.meide.common.enums.CacheType`中新增一个枚举值，定义缓存的前缀、过期时间

如

```java
//图片验证码 有效期2分钟
PICTURE_CAPTCHA_CODE("captcha_codes",2,TimeUnit.MINUTES),
```

这样做不仅方便切换缓存方案，也可以更好地对缓存时间等信息进行统一管理。

### 2. 使用注解在Service层配置缓存

- @Cacheable(value = "CacheType对应的前缀", key = "#关联方法参数")
  - 加在查询方法上，当调用方法时会根据key判断是否存在缓存，存在的话直接使用缓存，不存在的话就运行方法，将方法返回的结果存入缓存
- @CacheEvict(value = "前缀", key = "#关联方法参数")
  - 加在删除方法上，当调用方法时，会将参数对应的缓存删除
  - 如果修改的数据牵扯较多，要将该类型所有缓存删除。将`key`替换为`allEntries = true`
- @CachePut (value = "前缀",key = "#关联方法参数")
  - 加在修改方法上，当调用方法时，更新参数对应的缓存；

项目中字典相关业务中用到了这种缓存方式，但是缓存更新的逻辑比较简单粗暴（只要修改，全盘失效），如果后续业务中想使用这种缓存方式，可以提前设计，使用`@CachePut`进行细粒度缓存失效方案。
> 更详细使用方法：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html#cache-annotations

#### 2. 手动操作缓存

直接注入`com.meide.common.core.cashe.CacheUtil`接口，系统会根据配置指定的缓存类型注入`EhcacheUtil`或者`RedisCacheUtil`操作对应缓存对象;

直接使用接口方法即可

- 所有方法都需要CacheType，所以每种缓存都必须提前配置
- 参数key不需要拼接前缀，直接传入uuid之类的标记字符即可
- 当然`findAllByType`获取的key也是不带前缀的标记字符

项目中用到的地方较多，比如验证码`CaptchaController`，登录`TokenService`，在线用户管理`SysUserOnlineController`等。
## 使用其他缓存

如果已有缓存方案不能满足业务需求，需要使用其他缓存方案，可以仿照已有方案进行配置；

### 1. 配置文件

如果没有切换缓存的需求，可以直接将已有两套缓存完全排除：包括maven依赖、`framework`模块`com.meide.framework.config`包中的配置文件、CacheUtil实现类等。然后配置想使用的缓存。

否则，请在`config`包中进行缓存的配置，并仿照`EhcacheConfig`和`RedisConfig`排除其他缓存的自动配置

### 2. 实现`CacheUtil`接口

新缓存方案需要仿照已有方案的思路，实现该接口，并且通过`@ConditionalOnProperty`进行条件注入。

这样的话就可以在不修改原缓存业务代码的情况下实现缓存方案的切换。